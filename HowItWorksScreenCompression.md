# Java Remote Control - Method of Screen Compression #


---

## Purpose of this Document ##
This document should give enough information for a developer to create an application that can encode and decode a stream of frames as generated by Java Remote Control.

It does not give the implementation of an encoder or decoder, nor does it cover the transmission of keyboard and mouse information as is implemented in Java Remote Control.


---

## Assumptions ##
Java Remote Control compresses a series of snapshots (frames) of a PCs screen to send to a remote PC for viewing. The choice of compression methodology was based on a number of assumptions about PC desktop user interfaces:

  * Desktop user interfaces tend to only change in small areas from frame to frame
  * Large areas of the desktop user interface tend to be blocks of a single color
  * Any compressions has to be loss-less as screen text can be unreadable if lossy compression is used
  * The screen data needs to be compressed as the bandwidth limitations of Internet communication are the main bottle neck in the process of broadcasting screen frames


---

## Compression Process ##
Two types of compression are used by Java Remote Control to achieve an acceptable level of compression without too much processing overhead.

First a form of RLE (Run Length Encoding) is used to compress areas where blocks of the same color are found. This is the most efficient way to compress such information. Blocks of the same color are compressed into two elements. The first gives the length of the block and the second, the color. A detailed explanation of the RLE implementation used can be found in the section below. You can view the Java implementation here.

After RLE encoding has been applied, gzip compression is applied to each frame using the inbuilt gzip library distributed as part of the JVM.


---

## Transmission Process ##

  1. At the opening of a stream, the viewed screens width and height are sent.
> 2. Next the first frame’s data is compressed and written to the stream.
> 3. After the first frame has been sent, each screen snapshot from then on is compared with the previous frame.
> 4. Any areas where the screen has not changed are painted black before compression. This results in only changes in the screen from one frame to another being sent. Areas that have not been changed are compressed by the RLE algorithm.


---

## Decompression Process ##

An application wishing to display the remote screen must receive data from the compression stream.
The application must be capable of decompressing a gzip stream. This functionality is provided as a standard part of the JVM.
The first information sent in the stream is the width and height of the screen to be displayed.
Next the initial frame is sent as an RLE encoded block of data that has then been gzip compressed.
The application must decode this frames data and use it to reconstruct the screen over any previous frame that has been sent.
Each pixel on the screen is passed as a 3 byte RGB encoded block.

  * Byte 0: red (0-255)
  * Byte 1: green (0-255)
  * Byte 2: blue (0-255)


If all three bytes are 0, then the pixel is transparent and should not be plotted as the frame has not changed at this location since the last frame.

Note:  All values sent that are composed of multiple bytes i.e. 2 and 4 byte length integer words) are sent as big-endian values i.e. most significant byte (MSB) first.


---

## The Stream and Frame Header ##

The stream begins with two unsigned short integers each of of 2 bytes (16 bit)  length.
Byte 0: MSB
Byte 1: LSB
The first integer is the screen’s width in pixels.
The second integer is the screens height in pixels.

Next, each frames data is preceded with 5 or 9 bytes of header information. These form a single frame type marker and two 4 byte unsigned integers.

The first four bytes of the frame represent a 4 byte long (32 bit) integer that gives the time stamp value of the frame in milliseconds.  (This should be can be used when the stream has been recorded and is being used for playback to make sure that the frames are displayed at the same rate that they were recorded.)

This is followed by a single byte. If the value is 0, the frame has no changes from the previous frame and no further data for this frame will be sent, and the next frame header will follow. If the value is 1, the frame has changes and the second (4 byte) integer is sent, MSB first.

The second 4 byte (32 bit) integer gives the number of bytes in a frame after RLE encoding and gzip compression has been applied, MSB first. This integer value does not include the header information size and can be used to determine when the end of a single frame’s gzipped data has been read.


---

## The RLE Compression Algorithm ##
You can view the Java implementation here.

RLE compression is performed by an RLE encoder.

The RLE encoder passes over the data for one frame at a time.

Each frame consists of an array of pixels the size of which is the frames width multiplied by the screens height.

Each frame pixel consists of 3 unsigned bytes

  * Byte 0: red (0-255)
  * Byte 1: green (0-255)
  * Byte 2: blue (0-255)



The encoder has the data for the previous frame. (Where this is the first frame, the previous frames data is substituted with data for a frame filled with black)

The RLE encoder scans the array of pixel data.

If a pixel has changed since the previous frame and has been set to black (RGB 0,0,0) then the blue value is set to 1 (RGB 0,0,1). This is because the compression process treats a black pixel as transparent. Setting the blue value to 1 is not noticeable to a user, and the resulting color still looks black.

If a number of pixels are found (up to 255) that have not changed since the previous frame ( a compressed run)

  * Write a signed byte of value -1 (0xFF)
  * Write the number of pixels in the run as an unsigned byte


Else if a number of pixels (up to 126) have the same color (a compressed run)

  * Write the number of pixels in the run as a byte
  * Write the RGB value pixel of the pixel as three unsigned byte values:

  1. Byte 0: red (0-255)
  1. Byte 1: green (0-255)
  1. Byte 2: blue (0-255)


Else (an uncompressed run)

  * Write the number of pixels in the run (a 7 bit value) as a byte and set bit 7 (most significant bit) to 1, making it a negative signed byte
  * Write the  RGB value of each as three unsigned byte values:

  1. Byte 0: red (0-255)
  1. Byte 1: green (0-255)
  1. Byte 2: blue (0-255)


---

## The RLE Decompression Algorithm ##
You can view the Java implementation here.

RLE decompression is performed by an RLE decoder.

Read the 4 bytes that give the frames time stamp as a 32 bit integer (MSB first).

Read the 4 bytes that give the size of the data for the frame as a 32 bit integer (MSB first).

Read the data required for the frame.

Decode the gzipped data.

Create a frame container for the decompressed data with the data from the previous frame

Read Loop (remember this point you’ll need it in a bit)
Read the first byte of un gzipped data as a signed byte

If the value is -1 (0xFF)

  * This marks the start of a run of unchanged pixels.
  * Read the next byte. This is the length of the run, as an unsigned value.
  * Skip overwriting this number of pixels in the frame as they are unchanged.

Else if the value is less than 0

  * This marks the start of an uncompressed run
  * Take this byte’s lower 7 bits (bits 6 to 0) to convert it into a positive value. This is the size of the uncompressed run in pixels
  * Each pixel is represented by three unsigned bytes
  * Read blocks of three unsigned bytes

  * Byte 0: red
  * Byte 1: green
  * Byte 2: blue

  * If all three bytes have value 0x00, do not replace the pixel of the previous frame
  * else replace the frame pixel with the RGB values received
  * Repeat for the size of the uncompressed block



Else

  * This is a run of changed pixels of the same color
  * The value is the size of the block
  * Read a block of three unsigned bytes
    1. Byte 0: red
    1. Byte 1: green
    1. Byte 2: blue
  * If all three bytes are 0, do not replace the pixels of the previous frame
  * else replace size (the size of the block) pixels with the given color


End of Read Loop

Read the next byte of un gzipped data and repeat the Read Loop until you have run out of bytes for the frame

Display the frame and prepare for the next one.


---

## Future Enhancement ##

Currently, in the RLE algorithm, the initial byte of each block is used to give the size and type of the following block.

Values 1-126 are used to mark a run of pixels of the same color
Values 127-254 are used to mark a run of unchanged pixels
That leaves a value of 0 unused.

The value 0 could be used to mark an extended block, where the amount of data is much larger than the size of current maximum block sizes. Currently there is some overhead of using the current small block sizes with their initial byte. Some experimental work needs to be done to see if this brings down frame sizes significantly.

Frame headers currently have a frame type byte with possible values:

  * 0 = no change
  * 1 = has changes



This leaves the types of frame for values 2-255 undefined. These values could be used to change the type of compression used for a frame.

The described encoding scheme preserves the full accuracy of 24 bit RGB colour space.  For many purposes this may be unnecessary and 15 bit colour accuracy (5 bits per sub-pixel) encoding would suffice. Using such a scheme may reduce bandwidth demands considerably. Colour space data would be truncated at the encoding end (from 24 bit to 15 bit) and expanded back to 24 bit at the decoding end. Careful use of rounding (during encoding) and lookup tables (when decoding) can be used to increase the linearity of the colour space mappings, reducing the levels of visual artifacts introduced.  An implementation of a 15 bit encoding scheme is currently being developed.